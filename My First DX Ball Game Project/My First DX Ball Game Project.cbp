#include <GL/glut.h>
#ifdef _WIN32
#include <windows.h>
#include <mmsystem.h>
#pragma comment(lib, "Winmm.lib")
#endif

#include <cmath>
#include <vector>
#include <string>
#include <sstream>
#include <ctime>
#include <cstdlib>
#include <algorithm>
#include <iostream>
#include <fstream>
using namespace std;

// -------------------- STATE --------------------
enum GameState { STATE_HIGH_SCORES, STATE_MENU, STATE_NAME_INPUT, STATE_PLAYING, STATE_PAUSED, STATE_CREDITS, STATE_GAME_OVER };
GameState gameState = STATE_MENU;

// Menu
int selectedOption = 0;
vector<string> menuOptions = { "Play", "Difficulty: Medium", "Sound: On", "Highest Scores", "Credits", "Exit" };
float menuX=0.0f, menuStartY=0.0f, menuSpacing=30.0f;
int WIN_W=800, WIN_H=600;

// Difficulty & sound
string difficulty = "Medium";
bool soundOn=true;
bool musicPlaying=false;
string arcadeMusicPath = "D:\\Huddai\\Boring Time\\Projects\\My First DX Ball Game Project\\arcade.wav";

// Gameplay
int lives=3, score=0, levelNum=1;
float lastTime=0.0f;
string playerName="";
vector<pair<string,int>> highScores;

// Exit button
float exitBtnX=0, exitBtnY=0, exitBtnW=150, exitBtnH=40;

// Input
bool leftDown=false, rightDown=false;
bool mouseDragging=false;

// -------------------- PADDLE --------------------
struct Paddle {
    float x,y,halfW,h,speed;
    Paddle(){ reset(); }
    void reset(){ halfW=60; h=10; x=WIN_W/2.0f; y=40; speed=500.0f; }
    void draw() const {
        glBegin(GL_QUADS);
        glVertex2f(x-halfW, y-h);
        glVertex2f(x+halfW, y-h);
        glVertex2f(x+halfW, y+h);
        glVertex2f(x-halfW, y+h);
        glEnd();
    }
} paddle;

// -------------------- BALL --------------------
struct Ball {
    float x,y,vx,vy,r;
    bool stuck;
    Ball(){ reset(); }
    void reset(){ r=7.0f; x=paddle.x; y=paddle.y+20; vx=220; vy=220; stuck=true; }
    void draw() const {
        const int seg=24;
        glBegin(GL_TRIANGLE_FAN);
        glVertex2f(x,y);
        for(int i=0;i<=seg;i++){
            float a=(float)i/seg * 2.0f * 3.1415926535f;
            glVertex2f(x+cosf(a)*r, y+sinf(a)*r);
        }
        glEnd();
    }
} ball;

// -------------------- BRICK --------------------
struct Brick {
    float x,y,w,h;
    int hits;
    float r,g,b;
    bool alive() const { return hits>0; }
    void draw() const {
        if(!alive()) return;
        glColor3f(r,g,b);
        glBegin(GL_QUADS);
        glVertex2f(x,y); glVertex2f(x+w,y); glVertex2f(x+w,y+h); glVertex2f(x,y+h);
        glEnd();
        glColor3f(0,0,0);
        glBegin(GL_LINE_LOOP);
        glVertex2f(x,y); glVertex2f(x+w,y); glVertex2f(x+w,y+h); glVertex2f(x,y+h);
        glEnd();
    }
};
vector<Brick> bricks;

// -------------------- POWERUPS --------------------
enum PowerType { EXPAND, SLOW, EXTRA_LIFE };
struct PowerUp {
    float x,y,w,h,vy;
    PowerType type;
    bool active;
    PowerUp(float px,float py,PowerType t):x(px),y(py),w(18),h(18),vy(-80),type(t),active(true){}
    void draw() const {
        if(!active) return;
        switch(type){
            case EXPAND: glColor3f(0.2f,0.8f,0.2f); break;
            case SLOW: glColor3f(0.2f,0.2f,0.8f); break;
            case EXTRA_LIFE: glColor3f(0.9f,0.6f,0.1f); break;
        }
        glBegin(GL_QUADS);
        glVertex2f(x-w/2,y-h/2);
        glVertex2f(x+w/2,y-h/2);
        glVertex2f(x+w/2,y+h/2);
        glVertex2f(x-w/2,y+h/2);
        glEnd();
    }
    void update(float dt){ if(active) y += vy*dt; }
};
vector<PowerUp> powerups;

// -------------------- UTIL --------------------
float clampf(float v, float lo, float hi){ return (v<lo?lo:(v>hi?hi:v)); }
bool rectIntersect(float ax,float ay,float aw,float ah,float bx,float by,float bw,float bh){
    return !(ax+aw < bx || ax > bx+bw || ay+ah < by || ay > by+bh);
}

// -------------------- SOUND --------------------
void playMusic(bool inGame=true){
    if(!soundOn) return;
    PlaySound(arcadeMusicPath.c_str(), NULL, SND_ASYNC | SND_LOOP);
    musicPlaying = inGame;
}
void stopMusic(){
    PlaySound(NULL,0,0);
    musicPlaying = false;
}

// -------------------- LEVEL BUILD --------------------
void buildLevel(int lvl){
    bricks.clear();
    int rows=5+lvl/2, cols=10;
    float margin=50, gap=6;
    float brickAreaW = WIN_W - 2*margin;
    float bw = brickAreaW/cols - gap;
    float bh = 18;
    for(int r=0;r<rows;r++){
        for(int c=0;c<cols;c++){
            Brick b;
            b.x = margin + c*(bw+gap);
            b.y = WIN_H - margin - (r+1)*(bh+gap);
            b.w = bw; b.h = bh;
            b.hits = 1 + (r/3);
            b.r = 0.2f + 0.12f*r;
            b.g = 0.1f + 0.14f*c/cols;
            b.b = 0.4f - 0.04f*r;
            bricks.push_back(b);
        }
    }
}
void resetLevel(){ paddle.reset(); ball.reset(); powerups.clear(); buildLevel(levelNum); }

// -------------------- DIFFICULTY --------------------
void applyDifficulty(){
    if(difficulty=="Easy"){ paddle.halfW=90; ball.vx=180; ball.vy=180; lives=7; }
    else if(difficulty=="Medium"){ paddle.halfW=60; ball.vx=220; ball.vy=220; lives=5; }
    else { paddle.halfW=40; ball.vx=280; ball.vy=280; lives=3; }
}

// -------------------- GAME LOGIC --------------------
void spawnPowerUp(float x,float y){
    if(rand()%100<20){
        int p = rand()%3; PowerType t = (p==0?EXPAND:(p==1?SLOW:EXTRA_LIFE));
        powerups.emplace_back(x,y,t);
    }
}

void nextLevel(){ levelNum++; resetLevel(); }
void loseLife(){
    lives--;
    if(lives<=0){
        gameState = STATE_GAME_OVER;
        stopMusic();
        highScores.push_back({playerName, score});
        sort(highScores.begin(), highScores.end(), [](auto &a, auto &b){ return a.second>b.second; });
        ofstream fout("scores.txt");
        int cnt=0;
        for(auto &p: highScores){ fout << p.first << " " << p.second << "\n"; if(++cnt>=10) break; }
        fout.close();
    } else { ball.reset(); }
}

void updateGame(float dt){
    if(gameState != STATE_PLAYING) return;
    if(leftDown) paddle.x -= paddle.speed*dt;
    if(rightDown) paddle.x += paddle.speed*dt;
    paddle.x = clampf(paddle.x, paddle.halfW, WIN_W-paddle.halfW);

    if(ball.stuck){ ball.x=paddle.x; ball.y=paddle.y+20; }
    else { ball.x += ball.vx*dt; ball.y += ball.vy*dt; }

    if(ball.x-ball.r <=0){ ball.x=ball.r; ball.vx=fabs(ball.vx); }
    if(ball.x+ball.r >=WIN_W){ ball.x=WIN_W-ball.r; ball.vx=-fabs(ball.vx); }
    if(ball.y+ball.r >=WIN_H){ ball.y=WIN_H-ball.r; ball.vy=-fabs(ball.vy); }
    if(ball.y-ball.r <=0){ loseLife(); }

    if(ball.vy<0 && ball.y-ball.r <= paddle.y+paddle.h &&
       ball.x>=paddle.x-paddle.halfW && ball.x<=paddle.x+paddle.halfW){
        float hitPos = (ball.x-paddle.x)/paddle.halfW;
        float angle = hitPos*3.14159265f/3.0f;
        float speed = sqrt(ball.vx*ball.vx + ball.vy*ball.vy);
        ball.vx = speed*sin(angle); ball.vy=fabs(speed*cos(angle));
        ball.y=paddle.y+paddle.h+ball.r+1;
    }

    for(auto &b: bricks){
        if(!b.alive()) continue;
        if(rectIntersect(ball.x-ball.r,ball.y-ball.r,ball.r*2,ball.r*2,b.x,b.y,b.w,b.h)){
            ball.vy=-ball.vy; b.hits--;
            if(!b.alive()){ score+=100; spawnPowerUp(b.x+b.w/2,b.y+b.h/2); } else score+=50;
            break;
        }
    }

    for(auto &p: powerups) p.update(dt);
    for(auto &p: powerups){
        if(!p.active) continue;
        if(rectIntersect(p.x-p.w/2,p.y-p.h/2,p.w,p.h,
                         paddle.x-paddle.halfW,paddle.y-paddle.h,paddle.halfW*2,paddle.h*2)){
            p.active=false;
            switch(p.type){
                case EXPAND: paddle.halfW=clampf(paddle.halfW*1.5f,40,200); break;
                case SLOW: ball.vx*=0.7f; ball.vy*=0.7f; break;
                case EXTRA_LIFE: lives++; break;
            }
        }
    }
    powerups.erase(remove_if(powerups.begin(), powerups.end(), [](const PowerUp &p){ return !p.active||p.y<-50; }), powerups.end());

    bool anyAlive=false;
    for(auto &b: bricks) if(b.alive()){ anyAlive=true; break; }
    if(!anyAlive) nextLevel();
}

// -------------------- DRAW --------------------
void drawText(float x,float y,const string &s){
    glRasterPos2f(x,y);
    for(char c: s) glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, c);
}

void drawMenu(){
    glClearColor(0.05f,0.05f,0.08f,1.0f);
    glClear(GL_COLOR_BUFFER_BIT);
    glColor3f(1,1,1);
    drawText(WIN_W/2-80,WIN_H-100,"== DX BALL ==");
    menuX = WIN_W/2-70; menuStartY = WIN_H/2;
    for(int i=0;i<(int)menuOptions.size();++i){
        if(i==1) menuOptions[i] = "Difficulty: "+difficulty;
        if(i==2) menuOptions[i] = "Sound: "+string(soundOn?"On":"Off");
        float y = menuStartY - i*menuSpacing;
        if(i==selectedOption) glColor3f(1.0f,0.6f,0.2f); else glColor3f(1,1,1);
        drawText(menuX,y,menuOptions[i]);
    }
    glutSwapBuffers();
}

void drawGame(){
    glClearColor(0.12f,0.12f,0.12f,1.0f);
    glClear(GL_COLOR_BUFFER_BIT);

    glColor3f(0.0f, 0.0f, 0.5f); paddle.draw();
    glColor3f(1.0f, 0.0f, 0.0f); ball.draw();
    for(auto &b: bricks) b.draw();
    for(auto &p: powerups) p.draw();

    glColor3f(1,1,1);
    ostringstream ss;
    ss << "Player: " << playerName; drawText(10,WIN_H-42,ss.str());
    ss.str(""); ss<<"Score: "<<score; drawText(10,WIN_H-22,ss.str());
    ss.str(""); ss<<"Lives: "<<lives; drawText(150,WIN_H-22,ss.str());
    ss.str(""); ss<<"Level: "<<levelNum; drawText(260,WIN_H-22,ss.str());

    if(gameState==STATE_PAUSED){
        drawText(WIN_W/2-40, WIN_H/2+20, "PAUSED");
        exitBtnW = 150; exitBtnH = 40;
        exitBtnX = WIN_W/2 - exitBtnW/2;
        exitBtnY = WIN_H/2 - 40;
        glColor3f(0.8f,0.2f,0.2f);
        glBegin(GL_QUADS);
            glVertex2f(exitBtnX, exitBtnY);
            glVertex2f(exitBtnX+exitBtnW, exitBtnY);
            glVertex2f(exitBtnX+exitBtnW, exitBtnY+exitBtnH);
            glVertex2f(exitBtnX, exitBtnY+exitBtnH);
        glEnd();
        glColor3f(1,1,1);
        drawText(exitBtnX+30, exitBtnY+12, "EXIT TO MENU");
    }

    if(gameState==STATE_GAME_OVER){
        drawText(WIN_W/2-120, WIN_H/2+20, "== GAME OVER ==");
        drawText(WIN_W/2-90, WIN_H/2-6, string("Score: ")+to_string(score));
        drawText(WIN_W/2-230, WIN_H/2-36, "Press 'R' to 'Restart' or 'Enter' to go back to Main menu");
    }

    glutSwapBuffers();
}

// -------------------- INPUT --------------------
void keyboard(unsigned char key,int,int){
    if(key==27) exit(0);
    if(gameState==STATE_MENU){
        if(key==13){
            if(selectedOption==0) gameState=STATE_NAME_INPUT;
            else if(selectedOption==1){
                if(difficulty=="Easy") difficulty="Medium";
                else if(difficulty=="Medium") difficulty="Hard";
                else difficulty="Easy";
            } else if(selectedOption==2){
                soundOn=!soundOn; if(soundOn) playMusic(); else stopMusic();
            } else if(selectedOption==3){
                ifstream fin("scores.txt");
                highScores.clear(); string n; int s;
                while(fin>>n>>s) highScores.push_back({n,s});
                fin.close(); gameState=STATE_HIGH_SCORES;
            } else if(selectedOption==4) gameState=STATE_CREDITS;
            else if(selectedOption==5) exit(0);
        }
    } else if(gameState==STATE_NAME_INPUT){
        if(key==13 && !playerName.empty()){
            applyDifficulty(); score=0; levelNum=1; lives=3;
            resetLevel(); gameState=STATE_PLAYING; if(soundOn) playMusic();
        } else if(key==8 && !playerName.empty()) playerName.pop_back();
        else if(isalnum(key)||key==' '||key=='_') playerName.push_back(key);
    } else if(gameState==STATE_PLAYING){
        if(key==' '){ gameState=STATE_PAUSED; stopMusic(); }
    } else if(gameState==STATE_PAUSED){
        if(key==' '){ gameState=STATE_PLAYING; if(soundOn) playMusic(); }
    } else if(gameState==STATE_GAME_OVER){
        if(key=='r'||key=='R'){ applyDifficulty(); score=0; levelNum=1; lives=3;
            resetLevel(); gameState=STATE_PLAYING; if(soundOn) playMusic();
        } else if(key==13){ gameState=STATE_MENU; }
    } else if(gameState==STATE_CREDITS||gameState==STATE_HIGH_SCORES){
        if(key==13) gameState=STATE_MENU;
    }
}

void specialDown(int key,int,int){
    if(gameState==STATE_MENU){
        if(key==GLUT_KEY_UP) selectedOption=(selectedOption+menuOptions.size()-1)%menuOptions.size();
        if(key==GLUT_KEY_DOWN) selectedOption=(selectedOption+1)%menuOptions.size();
    } else if(gameState==STATE_PLAYING){
        if(key==GLUT_KEY_LEFT) leftDown=true;
        if(key==GLUT_KEY_RIGHT) rightDown=true;
    }
}
void specialUp(int key,int,int){
    if(key==GLUT_KEY_LEFT) leftDown=false;
    if(key==GLUT_KEY_RIGHT) rightDown=false;
}

void mouseClick(int button,int state,int mx,int my){
    float wx=(float)mx, wy=(float)(WIN_H-my);

    if(button==GLUT_LEFT_BUTTON){
        if(state==GLUT_DOWN){
            if(gameState==STATE_PAUSED){
                if(wx>=exitBtnX && wx<=exitBtnX+exitBtnW &&
                   wy>=exitBtnY && wy<=exitBtnY+exitBtnH){
                    gameState=STATE_MENU;
                    stopMusic();
                    return;
                }
            }
            if(gameState==STATE_CREDITS){
                gameState=STATE_MENU;
                return;
            }
            if(gameState==STATE_MENU){
                menuX=WIN_W/2-70; menuStartY=WIN_H/2;
                float boxW=180, boxH=22;
                for(int i=0;i<(int)menuOptions.size();++i){
                    float itemY = menuStartY - i*menuSpacing;
                    if(wx>menuX && wx<menuX+boxW && wy>itemY-5 && wy<itemY+boxH){
                        selectedOption=i;
                        keyboard(13,0,0);
                    }
                }
            }
            if(gameState==STATE_PLAYING){
                if(ball.stuck) ball.stuck=false;
                mouseDragging=true;
            }
        } else if(state==GLUT_UP){
            mouseDragging=false;
        }
    }
}

void mouseMotion(int mx,int my){
    if(gameState==STATE_PLAYING && mouseDragging){
        paddle.x = clampf((float)mx, paddle.halfW, WIN_W - paddle.halfW);
        if(ball.stuck) ball.x = paddle.x;
    }
}

// -------------------- RENDER LOOP --------------------
void display(){
    switch(gameState){
        case STATE_MENU: drawMenu(); break;
        case STATE_PLAYING:
        case STATE_PAUSED:
        case STATE_GAME_OVER: drawGame(); break;
        case STATE_NAME_INPUT:
            glClearColor(0.1f,0.1f,0.1f,1);
            glClear(GL_COLOR_BUFFER_BIT);
            glColor3f(1,1,1);
            drawText(WIN_W/2-90, WIN_H/2+20, "Enter your name:");
            drawText(WIN_W/2-60, WIN_H/2-10, playerName+"_");
            glutSwapBuffers();
            break;
        case STATE_CREDITS:
            glClearColor(0.05f,0.05f,0.05f,1);
            glClear(GL_COLOR_BUFFER_BIT);
            glColor3f(1,1,1);
            drawText(WIN_W/2-100, WIN_H/2+80,"Developed by   =^_^=");
            drawText(WIN_W/2-120, WIN_H/2+50,"1. Mahmudul Gony Miraz");
            drawText(WIN_W/2-120, WIN_H/2+20,"2. Mahara Zaman");
            drawText(WIN_W/2-130, WIN_H/2-40,"(Click Anywhere To Return)");
            glutSwapBuffers();
            break;
        case STATE_HIGH_SCORES:
            glClearColor(0.05f,0.05f,0.05f,1);
            glClear(GL_COLOR_BUFFER_BIT);
            glColor3f(1,1,1);
            drawText(WIN_W/2-80,WIN_H-60,"== HIGHEST SCORES ==");
            for(int i=0;i<(int)highScores.size()&&i<10;i++){
                ostringstream ss;
                ss<<i+1<<". "<<highScores[i].first<<" - "<<highScores[i].second;
                drawText(WIN_W/2-80,WIN_H-100-i*22,ss.str());
            }
            drawText(WIN_W/2-90,50,"Press Enter to return");
            glutSwapBuffers();
            break;
    }
}

void reshape(int w,int h){
    WIN_W=w; WIN_H=h;
    glViewport(0,0,w,h);
    glMatrixMode(GL_PROJECTION); glLoadIdentity();
    gluOrtho2D(0,w,0,h);
    glMatrixMode(GL_MODELVIEW);
}

void idle(){
    float now = glutGet(GLUT_ELAPSED_TIME)/1000.0f;
    float dt = now - lastTime;
    lastTime = now;
    updateGame(dt);
    glutPostRedisplay();
}

int main(int argc,char**argv){
    srand((unsigned)time(0));
    glutInit(&argc,argv);
    glutInitDisplayMode(GLUT_DOUBLE|GLUT_RGB);
    glutInitWindowSize(WIN_W,WIN_H);
    glutCreateWindow("DX BALL");

    glutDisplayFunc(display);
    glutKeyboardFunc(keyboard);
    glutSpecialFunc(specialDown);
    glutSpecialUpFunc(specialUp);
    glutMouseFunc(mouseClick);
    glutMotionFunc(mouseMotion);
    glutReshapeFunc(reshape);
    glutIdleFunc(idle);

    playMusic(false);
    lastTime = glutGet(GLUT_ELAPSED_TIME)/1000.0f;

    glutMainLoop();
    return 0;
}
